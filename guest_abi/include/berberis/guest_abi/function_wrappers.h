/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef BERBERIS_GUEST_ABI_FUNCTION_WRAPPERS_H_
#define BERBERIS_GUEST_ABI_FUNCTION_WRAPPERS_H_

#include <utility>

#include "berberis/guest_abi/guest_abi.h"  // IWYU pragma: export.
#include "berberis/guest_abi/guest_function_wrapper.h"
#include "berberis/guest_abi/guest_params.h"
#include "berberis/guest_abi/guest_type.h"
#include "berberis/runtime_primitives/host_code.h"
#include "berberis/runtime_primitives/host_function_wrapper_impl.h"

namespace berberis {

// Setup and run trampoline function.
template <typename Func,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant = GuestAbi::kDefaultAbi>
class TrampolineFuncGenerator;

template <typename Arg,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant = GuestAbi::kDefaultAbi>
struct GetGuestArgumentClass {
 public:
  static_assert(!std::is_pointer_v<Arg> || !std::is_function_v<std::remove_pointer_t<Arg>>);
  decltype(auto) operator()(Arg arg) const { return arg; }
};

template <typename Res,
          typename... Args,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant>
struct GetGuestArgumentClass<Res (*)(Args...), kCallingConventionsVariant> {
 public:
  decltype(auto) operator()(GuestType<Res (*)(Args...)> func) const {
    return WrapGuestFunction(func, "AutoGeneratedWrapper");
  }
};

template <typename Arg,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant = GuestAbi::kDefaultAbi>
inline constexpr auto GetGuestArgument = GetGuestArgumentClass<Arg, kCallingConventionsVariant>{};

template <typename Arg,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant = GuestAbi::kDefaultAbi>
struct GetGuestResultClass {
 public:
  static_assert(!std::is_pointer_v<Arg> || !std::is_function_v<std::remove_pointer_t<Arg>>);
  decltype(auto) operator()(Arg arg) const { return arg; }
};

template <typename Res,
          typename... Args,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant>
struct GetGuestResultClass<Res (*)(Args...), kCallingConventionsVariant> {
 public:
  decltype(auto) operator()(Res (*func)(Args...)) const {
    WrapHostFunctionImpl(reinterpret_cast<HostCode>(func),
                         TrampolineFuncGenerator<Res(Args...), kCallingConventionsVariant>::Func,
                         "AutoGeneratedWrapper");
    return func;
  }
};

template <typename Arg,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant = GuestAbi::kDefaultAbi>
inline constexpr auto GetGuestResult = GetGuestResultClass<Arg, kCallingConventionsVariant>{};

template <typename Res,
          typename... Args,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant>
class TrampolineFuncGenerator<Res(Args...), kCallingConventionsVariant> {
 public:
  static void Func(HostCode callee, ThreadState* state) {
    using Func = Res (*)(Args...);
    auto func = reinterpret_cast<Func>(const_cast<void*>(callee));
    FuncImpl(func, state, std::make_index_sequence<sizeof...(Args)>());
  }

 private:
  template <typename Func, typename std::size_t... I>
  static void FuncImpl(Func func, ThreadState* state, std::index_sequence<I...>) {
    GuestParamsValues<Func, kCallingConventionsVariant> params(state);
    if constexpr (std::is_same_v<Res, void>) {
      func(GetGuestArgument<std::tuple_element_t<I, std::tuple<Args...>>,
                            kCallingConventionsVariant>(params.template get<I>())...);
    } else {
      auto&& [ret] = GuestReturnReference<Func, kCallingConventionsVariant>(state);
      ret = GetGuestResult<Res, kCallingConventionsVariant>(
          func(GetGuestArgument<std::tuple_element_t<I, std::tuple<Args...>>,
                                kCallingConventionsVariant>(params.template get<I>())...));
    }
  }
};

// Pointer to function.
template <typename Res,
          typename... Args,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant>
class TrampolineFuncGenerator<Res (*)(Args...), kCallingConventionsVariant>
    : public TrampolineFuncGenerator<Res(Args...), kCallingConventionsVariant> {};

// Syntax sugar.
template <typename Func,
          GuestAbi::CallingConventionsVariant kCallingConventionsVariant = GuestAbi::kDefaultAbi>
constexpr TrampolineFunc GetTrampolineFunc() {
  return TrampolineFuncGenerator<Func, kCallingConventionsVariant>::Func;
}

template <GuestAbi::CallingConventionsVariant kCallingConventionsVariant = GuestAbi::kDefaultAbi,
          typename Func>
inline void WrapHostFunction(Func func, const char* name) {
  WrapHostFunctionImpl(reinterpret_cast<HostCode>(func),
                       GetTrampolineFunc<Func, kCallingConventionsVariant>(),
                       name);
}

}  // namespace berberis

#endif  // BERBERIS_GUEST_ABI_FUNCTION_WRAPPERS_H_
