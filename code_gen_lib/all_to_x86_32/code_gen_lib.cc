/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "berberis/code_gen_lib/code_gen_lib.h"

#include "berberis/assembler/machine_code.h"
#include "berberis/assembler/x86_32.h"
#include "berberis/base/bit_util.h"
#include "berberis/base/config.h"
#include "berberis/calling_conventions/calling_conventions_x86_32.h"
#include "berberis/code_gen_lib/code_gen_lib_arch.h"
#include "berberis/guest_state/guest_addr.h"
#include "berberis/guest_state/guest_state.h"
#include "berberis/instrument/trampolines.h"
#include "berberis/runtime_primitives/host_code.h"
#include "berberis/runtime_primitives/translation_cache.h"

namespace berberis {

namespace x86_32 {

namespace {

// State register pointer must be callee saved.
// Use of EBP allows shorter context read instructions.
constexpr Assembler::Register kStateRegister = Assembler::ebp;

// Emitted code checks if some emulated signal is pending. If yes,
// it returns to the main dispatcher to handle the signal.
// To ensure we don't loop endlessly in generated code without checks
// for pending signals, this must be called on every exit from region (given
// there are no loops in regions). Thus we call it in EmitJump for static
// branches out of the regions and EmitDispatch for dynamic ones.
void EmitCheckSignalsAndMaybeReturn(Assembler* as) {
  // C++:
  //   std::atomic_int_least8_t pending_signals_status;
  //   uint8_t status = pending_signals_status.load(std::memory_order_acquire);
  //   if (status == kPendingSignalsPresent) { ... }
  // x86_32 asm:
  //   cmpb pending_signals_status, kPendingSignalsPresent
  const size_t offset = offsetof(ThreadState, pending_signals_status);
  as->Cmpb({.base = kStateRegister, .disp = offset}, kPendingSignalsPresent);
  as->Jcc(Assembler::Condition::kEqual, kEntryExitGeneratedCode);
}

// The offset of insn_addr is hard-coded in runtime_library_x86_32.S.  The
// static_assert below is to ensure that the offset is still as expected.
static_assert(offsetof(ThreadState, cpu.insn_addr) == 0x48, "");

void EmitDispatch(Assembler* as, Assembler::Register target) {
  // We are carrying target over in EAX, but we also need it in another
  // temporary register that we'll clobber during mapping to the host address.
  Assembler::Register reg1{Assembler::no_register};
  if (target == Assembler::eax) {
    reg1 = Assembler::ecx;
    as->Movl(reg1, target);
  } else {
    reg1 = target;
    as->Movl(Assembler::eax, target);
  }

  // Allocate another temporary register.
  Assembler::Register reg2 = reg1 == Assembler::ecx ? Assembler::edx : Assembler::ecx;

  if (!config::kLinkJumpsBetweenRegions) {
    as->Jmp(kEntryExitGeneratedCode);
    return;
  }

  EmitCheckSignalsAndMaybeReturn(as);

  auto* translation_cache = TranslationCache::GetInstance();
  auto main_table_ptr = translation_cache->main_table_ptr();

  // eax, reg1: guest pc
  //
  // movzwl %eax,%reg2
  // shr    $0x10,%reg1
  // mov    main_table_ptr(,%reg1,4),%reg1
  // jmp    *(%reg1,%reg2,4)
  as->Movzxwl(reg2, Assembler::eax);
  as->Shrl(reg1, int8_t{16});
  as->Movl(
      reg1,
      {.index = reg1, .scale = Assembler::kTimesFour, .disp = bit_cast<int32_t>(main_table_ptr)});
  as->Jmpl({.base = reg1, .index = reg2, .scale = Assembler::kTimesFour});
}

void GenTrampolineAdaptor(MachineCode* mc,
                          GuestAddr pc,
                          HostCode marshall,
                          const void* callee,
                          const char* name) {
  Assembler as(mc);
  // void Trampoline(void*, ThreadState*);
  // void LogTrampoline(ThreadState*, const char*);
  EmitAllocStackFrame(&as, 8);

  // Update insn_addr to the current PC.  This way, code generated by this
  // function does not require insn_addr to be up to date upon entry.  Note that
  // the trampoline that we call requires insn_addr to be up to date.
  as.Movl({.base = kStateRegister, .disp = offsetof(ThreadState, cpu.insn_addr)}, pc);
  as.Movl({.base = kStateRegister, .disp = offsetof(ThreadState, residence)},
          kOutsideGeneratedCode);

  if (kInstrumentTrampolines) {
    if (auto instrument = GetOnTrampolineCall(name)) {
      as.Movl({.base = as.esp}, kStateRegister);
      as.Movl({.base = as.esp, .disp = 4}, bit_cast<int32_t>(name));
      as.Call(AsHostCode(instrument));
    }
  }

  as.Movl({.base = as.esp}, reinterpret_cast<uintptr_t>(callee));
  as.Movl({.base = as.esp, .disp = 4}, kStateRegister);
  as.Call(marshall);

  if (kInstrumentTrampolines) {
    if (auto instrument = GetOnTrampolineReturn(name)) {
      as.Movl({.base = as.esp}, kStateRegister);
      as.Movl({.base = as.esp, .disp = 4}, bit_cast<int32_t>(name));
      as.Call(AsHostCode(instrument));
    }
  }

  EmitFreeStackFrame(&as, 8);
  // jump to guest return address
  as.Movl(as.eax, {.base = kStateRegister, .disp = kReturnAddressRegisterOffset});
  // We are returning to generated code.
  as.Movl({.base = kStateRegister, .disp = offsetof(ThreadState, residence)}, kInsideGeneratedCode);
  EmitDispatch(&as, as.eax);
  as.Finalize();
}

}  // namespace

void EmitAllocStackFrame(Assembler* as, uint32_t frame_size) {
  if (frame_size > config::kFrameSizeAtTranslatedCode) {
    uint32_t extra_size = AlignUp(frame_size - config::kFrameSizeAtTranslatedCode,
                                  CallingConventions::kStackAlignmentBeforeCall);
    as->Subl(Assembler::esp, extra_size);
  }
}

void EmitFreeStackFrame(Assembler* as, uint32_t frame_size) {
  if (frame_size > config::kFrameSizeAtTranslatedCode) {
    uint32_t extra_size = AlignUp(frame_size - config::kFrameSizeAtTranslatedCode,
                                  CallingConventions::kStackAlignmentBeforeCall);
    as->Addl(Assembler::esp, extra_size);
  }
}

void EmitJump(Assembler* as, GuestAddr target) {
  // Attention! Always sync insn_addr as we may be jumping out of translated code (e.g.
  // non-translated code handler or trampolines that require synced state to run signal handlers).
  as->Movl(Assembler::eax, target);

  if (!config::kLinkJumpsBetweenRegions) {
    as->Jmp(kEntryExitGeneratedCode);
    return;
  }

  EmitCheckSignalsAndMaybeReturn(as);

  // Now we have same stack state as we had on entry to this
  // code, so we can just do tail call to other translation unit.
  as->Jmpl({.disp = bit_cast<int32_t>(TranslationCache::GetInstance()->GetHostCodePtr(target))});
}

// ATTENTION: 'target' should be a general register - see constraints for PseudoIndirectJump!
void EmitIndirectJump(Assembler* as, Assembler::Register target) {
  EmitDispatch(as, target);
}

}  // namespace x86_32

void GenTrampolineAdaptor(MachineCode* mc,
                          GuestAddr pc,
                          HostCode marshall,
                          const void* callee,
                          const char* name) {
  x86_32::GenTrampolineAdaptor(mc, pc, marshall, callee, name);
}

}  // namespace berberis
